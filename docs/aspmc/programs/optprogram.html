<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>aspmc.programs.optprogram API documentation</title>
<meta name="description" content="Program module providing the optimizing progam class." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>aspmc.programs.optprogram</code></h1>
</header>
<section id="section-intro">
<p>Program module providing the optimizing progam class.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
Program module providing the optimizing progam class.
&#34;&#34;&#34;

import re
import numpy as np
import logging

from aspmc.programs.program import Program, UnsupportedException

from aspmc.parsing.clingoparser.clingoext import ClingoRule, Control

from lark import Lark
from aspmc.parsing.lark_optparser import GRAMMAR, OptProgramTransformer, WeakConstraint
import aspmc.programs.grounder as grounder

import aspmc.semirings.minplus as semiring

from aspmc.util import *
from aspmc.programs.naming import *

logger = logging.getLogger(&#34;aspmc&#34;)

class OptProgram(Program):
    &#34;&#34;&#34;A class for programs that state optimization problems. 

    Should be specified using only normal rules, choice rules and weak constraints.

    Grounding of these programs (and subclasses thereof) should follow the following strategy:

    * `_prepare_grounding(self, program)` should take the output of the parser 
        (i.e. a list of rules and special objects) and process all the rules and special objects
        transforming them either into other rules or into strings that can be given to the grounder.
    * the output of `_prepare_grounding(self, program)` is transformed to one program string via

            &#39;\\n&#39;.join([ str(r) for r in program ])
        
        This string will be given to the grounder, which produces a clingo control object.
    * `_process_grounding(self, clingo_control)` should take this clingo control object and process the
        grounding in an appropriate way (and draw some information from it optionally about weights, special objects).
        The resulting processed clingo_control object must only know about the 
        rules that should be seen in the base program class.

    Thus, subclasses can override `_prepare_grounding` and `_process_grounding` (and optionally call the superclass methods) 
    to handle their extras. See aspmc.programs.meuprogram or aspmc.programs.smprogram for examples.

    Args:
        program_str (:obj:`string`): A string containing a part of the program. 
        May be the empty string.
        program_files (:obj:`list`): A list of string that are paths to files which contain programs. May be an empty list.

    Attributes:
        semiring (:obj:`module`): The semiring module to be used. 
        weights (:obj:`dict`): The dictionary from atom names to their weight.
    &#34;&#34;&#34;
    def __init__(self, program_str, program_files):
        self.semiring = semiring
        self.weights = {}
        for path in program_files:
            with open(path) as file_:
                program_str += file_.read()
        # parse
        my_grammar = GRAMMAR
        parser = Lark(my_grammar, start=&#39;program&#39;, parser=&#39;lalr&#39;, transformer=OptProgramTransformer())
        program = parser.parse(program_str)

        # ground
        clingo_control = Control()
        self._ground(clingo_control, program)

        # initialize the superclass
        Program.__init__(self, clingo_control = clingo_control)

    def _ground(self, clingo_control, program):
        # do the grounding in three steps:
        # 1. transform the parsed rules into asp rules
        program = self._prepare_grounding(program)
        # 2. give the asp rules to the grounder
        clingo_str = &#39;\n&#39;.join([ str(r) for r in program ])
        grounder.ground(clingo_control, program_str = clingo_str, program_files = [])
        # 3. take care of possible extras
        self._process_grounding(clingo_control)

    def _prepare_grounding(self, program):
        new_program = []
        for r in program:
            if isinstance(r, str):
                new_program.append(r)
            elif isinstance(r, WeakConstraint):
                new_program.append(f&#34;{INTERNAL_PENALTY}({&#39;,&#39;.join([ str(term) for term in r.terms ])},{r.weight}):-{&#39;,&#39;.join([ str(atom) for atom in r.body ])}.&#34;)
            else:
                new_program.append(r)
        return new_program

    def _process_grounding(self, clingo_control):
        symbol_map = {}
        for sym in clingo_control.symbolic_atoms:
            symbol_map[sym.literal] = str(sym.symbol)
        for o in clingo_control.ground_program.objects:
            if isinstance(o, ClingoRule):
                head_name = &#34;&#34; if len(o.head) == 0 else symbol_map[abs(o.head[0])]
                # check if the rule corresponds to a weak constraint
                if head_name.startswith(INTERNAL_PENALTY):
                    # find out the penalty of this atom
                    idx = head_name.rfind(&#34;,&#34;)
                    penalty = semiring.MinPlusFloat(float(head_name[idx+1:-1]))
                    self.weights[head_name] = penalty
                

    def _prog_string(self, program):
        # TODO: return the weak constraint program again
        result = &#34;&#34;
        for v in self._guess:
            result += f&#34;{{{self._external_name(v)}}}.\n&#34;
        for r in program:
            result += &#34;;&#34;.join([self._external_name(v) for v in r.head])
            if len(r.body) &gt; 0:
                result += &#34;:-&#34;
                result += &#34;,&#34;.join([(&#34;not &#34; if v &lt; 0 else &#34;&#34;) + self._external_name(abs(v)) for v in r.body])
            result += &#34;.\n&#34;
        return result

    def _finalize_cnf(self):
        weight_list = self.get_weights()
        for v in range(self._cnf.nr_vars*2):
            self._cnf.weights[to_dimacs(v)] = weight_list[v]
        self._cnf.semirings = [ self.semiring ]
        self._cnf.quantified = [ list(range(1, self._cnf.nr_vars + 1)) ]
        query_cnt = 1
        for v in self._deriv:
            if all(self._cnf.weights[v][i] == self.semiring.one() and self._cnf.weights[-v][i] == self.semiring.one() for i in range(query_cnt)):
                self._cnf.auxilliary.add(v)

    def get_weights(self):
        query_cnt = 1
        varMap = { name : var for var, name in self._nameMap.items() }
        weight_list = [ np.full(query_cnt, self.semiring.one(), dtype=self.semiring.dtype) for _ in range(self._cnf.nr_vars*2) ]
        for name in self.weights:
            weight_list[to_pos(varMap[name])] = np.full(query_cnt, self.weights[name], dtype=self.semiring.dtype)
        return weight_list

    def get_queries(self):
        return []

    # def solve_clingo(self):
    #     import clingo
    #     control = clingo.Control()
    #     control.add(&#34;base&#34;, [], self._prog_string(self._program))
    #     control.ground([(&#39;base&#39;, [])])</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="aspmc.programs.optprogram.OptProgram"><code class="flex name class">
<span>class <span class="ident">OptProgram</span></span>
<span>(</span><span>program_str, program_files)</span>
</code></dt>
<dd>
<div class="desc"><p>A class for programs that state optimization problems. </p>
<p>Should be specified using only normal rules, choice rules and weak constraints.</p>
<p>Grounding of these programs (and subclasses thereof) should follow the following strategy:</p>
<ul>
<li><code>_prepare_grounding(self, program)</code> should take the output of the parser
(i.e. a list of rules and special objects) and process all the rules and special objects
transforming them either into other rules or into strings that can be given to the grounder.</li>
<li>
<p>the output of <code>_prepare_grounding(self, program)</code> is transformed to one program string via</p>
<pre><code>'\n'.join([ str(r) for r in program ])
</code></pre>
<p>This string will be given to the grounder, which produces a clingo control object.
* <code>_process_grounding(self, clingo_control)</code> should take this clingo control object and process the
grounding in an appropriate way (and draw some information from it optionally about weights, special objects).
The resulting processed clingo_control object must only know about the
rules that should be seen in the base program class.</p>
</li>
</ul>
<p>Thus, subclasses can override <code>_prepare_grounding</code> and <code>_process_grounding</code> (and optionally call the superclass methods)
to handle their extras. See aspmc.programs.meuprogram or aspmc.programs.smprogram for examples.</p>
<h2 id="args">Args</h2>
<p>program_str (:obj:<code>string</code>): A string containing a part of the program.
May be the empty string.
program_files (:obj:<code>list</code>): A list of string that are paths to files which contain programs. May be an empty list.</p>
<h2 id="attributes">Attributes</h2>
<p>semiring (:obj:<code>module</code>): The semiring module to be used.
weights (:obj:<code>dict</code>): The dictionary from atom names to their weight.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class OptProgram(Program):
    &#34;&#34;&#34;A class for programs that state optimization problems. 

    Should be specified using only normal rules, choice rules and weak constraints.

    Grounding of these programs (and subclasses thereof) should follow the following strategy:

    * `_prepare_grounding(self, program)` should take the output of the parser 
        (i.e. a list of rules and special objects) and process all the rules and special objects
        transforming them either into other rules or into strings that can be given to the grounder.
    * the output of `_prepare_grounding(self, program)` is transformed to one program string via

            &#39;\\n&#39;.join([ str(r) for r in program ])
        
        This string will be given to the grounder, which produces a clingo control object.
    * `_process_grounding(self, clingo_control)` should take this clingo control object and process the
        grounding in an appropriate way (and draw some information from it optionally about weights, special objects).
        The resulting processed clingo_control object must only know about the 
        rules that should be seen in the base program class.

    Thus, subclasses can override `_prepare_grounding` and `_process_grounding` (and optionally call the superclass methods) 
    to handle their extras. See aspmc.programs.meuprogram or aspmc.programs.smprogram for examples.

    Args:
        program_str (:obj:`string`): A string containing a part of the program. 
        May be the empty string.
        program_files (:obj:`list`): A list of string that are paths to files which contain programs. May be an empty list.

    Attributes:
        semiring (:obj:`module`): The semiring module to be used. 
        weights (:obj:`dict`): The dictionary from atom names to their weight.
    &#34;&#34;&#34;
    def __init__(self, program_str, program_files):
        self.semiring = semiring
        self.weights = {}
        for path in program_files:
            with open(path) as file_:
                program_str += file_.read()
        # parse
        my_grammar = GRAMMAR
        parser = Lark(my_grammar, start=&#39;program&#39;, parser=&#39;lalr&#39;, transformer=OptProgramTransformer())
        program = parser.parse(program_str)

        # ground
        clingo_control = Control()
        self._ground(clingo_control, program)

        # initialize the superclass
        Program.__init__(self, clingo_control = clingo_control)

    def _ground(self, clingo_control, program):
        # do the grounding in three steps:
        # 1. transform the parsed rules into asp rules
        program = self._prepare_grounding(program)
        # 2. give the asp rules to the grounder
        clingo_str = &#39;\n&#39;.join([ str(r) for r in program ])
        grounder.ground(clingo_control, program_str = clingo_str, program_files = [])
        # 3. take care of possible extras
        self._process_grounding(clingo_control)

    def _prepare_grounding(self, program):
        new_program = []
        for r in program:
            if isinstance(r, str):
                new_program.append(r)
            elif isinstance(r, WeakConstraint):
                new_program.append(f&#34;{INTERNAL_PENALTY}({&#39;,&#39;.join([ str(term) for term in r.terms ])},{r.weight}):-{&#39;,&#39;.join([ str(atom) for atom in r.body ])}.&#34;)
            else:
                new_program.append(r)
        return new_program

    def _process_grounding(self, clingo_control):
        symbol_map = {}
        for sym in clingo_control.symbolic_atoms:
            symbol_map[sym.literal] = str(sym.symbol)
        for o in clingo_control.ground_program.objects:
            if isinstance(o, ClingoRule):
                head_name = &#34;&#34; if len(o.head) == 0 else symbol_map[abs(o.head[0])]
                # check if the rule corresponds to a weak constraint
                if head_name.startswith(INTERNAL_PENALTY):
                    # find out the penalty of this atom
                    idx = head_name.rfind(&#34;,&#34;)
                    penalty = semiring.MinPlusFloat(float(head_name[idx+1:-1]))
                    self.weights[head_name] = penalty
                

    def _prog_string(self, program):
        # TODO: return the weak constraint program again
        result = &#34;&#34;
        for v in self._guess:
            result += f&#34;{{{self._external_name(v)}}}.\n&#34;
        for r in program:
            result += &#34;;&#34;.join([self._external_name(v) for v in r.head])
            if len(r.body) &gt; 0:
                result += &#34;:-&#34;
                result += &#34;,&#34;.join([(&#34;not &#34; if v &lt; 0 else &#34;&#34;) + self._external_name(abs(v)) for v in r.body])
            result += &#34;.\n&#34;
        return result

    def _finalize_cnf(self):
        weight_list = self.get_weights()
        for v in range(self._cnf.nr_vars*2):
            self._cnf.weights[to_dimacs(v)] = weight_list[v]
        self._cnf.semirings = [ self.semiring ]
        self._cnf.quantified = [ list(range(1, self._cnf.nr_vars + 1)) ]
        query_cnt = 1
        for v in self._deriv:
            if all(self._cnf.weights[v][i] == self.semiring.one() and self._cnf.weights[-v][i] == self.semiring.one() for i in range(query_cnt)):
                self._cnf.auxilliary.add(v)

    def get_weights(self):
        query_cnt = 1
        varMap = { name : var for var, name in self._nameMap.items() }
        weight_list = [ np.full(query_cnt, self.semiring.one(), dtype=self.semiring.dtype) for _ in range(self._cnf.nr_vars*2) ]
        for name in self.weights:
            weight_list[to_pos(varMap[name])] = np.full(query_cnt, self.weights[name], dtype=self.semiring.dtype)
        return weight_list

    def get_queries(self):
        return []

    # def solve_clingo(self):
    #     import clingo
    #     control = clingo.Control()
    #     control.add(&#34;base&#34;, [], self._prog_string(self._program))
    #     control.ground([(&#39;base&#39;, [])])</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="aspmc.programs.program.Program" href="program.html#aspmc.programs.program.Program">Program</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="aspmc.programs.program.Program" href="program.html#aspmc.programs.program.Program">Program</a></b></code>:
<ul class="hlist">
<li><code><a title="aspmc.programs.program.Program.choose_clark_completion" href="program.html#aspmc.programs.program.Program.choose_clark_completion">choose_clark_completion</a></code></li>
<li><code><a title="aspmc.programs.program.Program.clark_completion" href="program.html#aspmc.programs.program.Program.clark_completion">clark_completion</a></code></li>
<li><code><a title="aspmc.programs.program.Program.encoding_stats" href="program.html#aspmc.programs.program.Program.encoding_stats">encoding_stats</a></code></li>
<li><code><a title="aspmc.programs.program.Program.get_cnf" href="program.html#aspmc.programs.program.Program.get_cnf">get_cnf</a></code></li>
<li><code><a title="aspmc.programs.program.Program.get_queries" href="program.html#aspmc.programs.program.Program.get_queries">get_queries</a></code></li>
<li><code><a title="aspmc.programs.program.Program.get_weights" href="program.html#aspmc.programs.program.Program.get_weights">get_weights</a></code></li>
<li><code><a title="aspmc.programs.program.Program.td_guided_both_clark_completion" href="program.html#aspmc.programs.program.Program.td_guided_both_clark_completion">td_guided_both_clark_completion</a></code></li>
<li><code><a title="aspmc.programs.program.Program.td_guided_clark_completion" href="program.html#aspmc.programs.program.Program.td_guided_clark_completion">td_guided_clark_completion</a></code></li>
<li><code><a title="aspmc.programs.program.Program.tpUnfold" href="program.html#aspmc.programs.program.Program.tpUnfold">tpUnfold</a></code></li>
<li><code><a title="aspmc.programs.program.Program.treeprocess" href="program.html#aspmc.programs.program.Program.treeprocess">treeprocess</a></code></li>
<li><code><a title="aspmc.programs.program.Program.write_dimacs" href="program.html#aspmc.programs.program.Program.write_dimacs">write_dimacs</a></code></li>
<li><code><a title="aspmc.programs.program.Program.write_prog" href="program.html#aspmc.programs.program.Program.write_prog">write_prog</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="aspmc.programs" href="index.html">aspmc.programs</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="aspmc.programs.optprogram.OptProgram" href="#aspmc.programs.optprogram.OptProgram">OptProgram</a></code></h4>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>