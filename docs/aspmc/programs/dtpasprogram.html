<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>aspmc.programs.dtpasprogram API documentation</title>
<meta name="description" content="Maximum Expected Utility ASProgram module specializing the NestedAlgebraicProgam class." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>aspmc.programs.dtpasprogram</code></h1>
</header>
<section id="section-intro">
<p>Maximum Expected Utility ASProgram module specializing the NestedAlgebraicProgam class.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">#!/usr/bin/env python3

&#34;&#34;&#34;
Maximum Expected Utility ASProgram module specializing the NestedAlgebraicProgam class.
&#34;&#34;&#34;
import logging

from aspmc.parsing.clingoparser.clingoext import Control

from aspmc.programs.problogprogram import ProblogProgram
from aspmc.programs.nestedalgebraicprogram import NestedAlgebraicProgram
from lark import Lark
from aspmc.parsing.lark_parser import GRAMMAR, ProblogTransformer
from aspmc.util import *

import aspmc.semirings.maxmaxplusdecisions as first_semiring
import aspmc.semirings.twograd as second_semiring # the gradient semiring and the expected utility are the same
import aspmc.semirings.minmaxplus as third_semiring 
import aspmc.semirings.probabilistic as semiring

logger = logging.getLogger(&#34;aspmc&#34;)

class DTPASProgram(NestedAlgebraicProgram, ProblogProgram):
    &#34;&#34;&#34;A class for Maximum Expected Utility programs. 

    The syntax for these programs is the same as for ProbLog in MEU mode. 
    This means that the probabilistic part is specified as usual,
    utility atoms `a`, i.e. atoms whose truth adds utility value `u` to the model, must be given as `utility(a, u).` and
    the decision atoms `d`, whose assignment should be maximized over should be given as `decision(d).`.

    Subclasses `TwoAlgebraicProgram` since it is a second level problem.

    Overrides the `_prepare_grounding` method to deal with utilities and decisions.

    Args:
        program_str (:obj:`string`): A string containing a part of the program in MEU ProbLog syntax. 
        May be the empty string.
        program_files (:obj:`list`): A list of string that are paths to files which contain programs in 
        MEU ProbLog syntax that should be included. May be an empty list.
    &#34;&#34;&#34;
    def __init__(self, program_str, program_files):
        self.semiring = semiring
        self.weights = {}
        self.utilities = {}
        self.decisions = []
        self.queries = []
        self.annotated_disjunctions = []
        for path in program_files:
            with open(path) as file_:
                program_str += file_.read()
        
        # parse the program
        my_grammar = GRAMMAR + f&#34;&#34;&#34;
        QUESTION_MARK : &#34;?&#34;
        %override weight : /{self.semiring.pattern}/ | variable | QUESTION_MARK
        &#34;&#34;&#34;
        parser = Lark(my_grammar, start=&#39;program&#39;, parser=&#39;lalr&#39;, transformer=ProblogTransformer())
        program = parser.parse(program_str)

        # ground the program
        clingo_control = Control()
        self._ground(clingo_control, program)

        # set the weights
        first_weight_list = {}
        # weights for the maxplus semiring
        first_semiring.names = [ name for name in self.decisions ]
        for i,name in enumerate(self.decisions):
            first_weight_list[(name, True)] = first_semiring.MinMaxPlusFloat((0, 0), (2**i, 2**i))
            first_weight_list[(name, False)] = first_semiring.one()
        # weights for the expected utility semiring
        second_weight_list = {}
        for name in self.weights:
            second_weight_list[(name, True)] = [self.weights[name], 0.0]
            second_weight_list[(name, False)] = [1.0 - self.weights[name], 0.0]
        third_weight_list = {}
        for (name, phase) in self.utilities:
            if (name, phase) in second_weight_list:
                if (name, phase) in first_weight_list:
                    logger.error(f&#34;Variable {name} cannot be both a decision and probabilistic variable.&#34;)
                    exit(-1)
                second_weight_list[(name, phase)][1] = second_weight_list[(name, phase)][0]*self.utilities[(name, phase)]
            elif (name, phase) in first_weight_list:
                first_weight_list[(name, phase)].value[0] = self.utilities[(name, phase)]
                first_weight_list[(name, phase)].value[1] = self.utilities[(name, phase)]
            else:
                third_weight_list[(name, phase)] = self.utilities[(name, phase)]
        second_weight_list = { i : second_semiring.parse(f&#34;({w[0]},{w[1]},{w[1]})&#34;) for (i, w) in second_weight_list.items() }
        third_weight_list = { i : third_semiring.parse(f&#34;({w},{w})&#34;) for (i, w) in third_weight_list.items() }

        semirings = [ first_semiring, second_semiring, third_semiring ]
        weights_per_semiring = [ first_weight_list, second_weight_list, third_weight_list ]
        transforms = [ &#34;lambda w : (w.value[1], w.value[2])&#34;, &#34;lambda w : (1.0, w.value[0], w.value[1])&#34; ]
        NestedAlgebraicProgram.__init__(self, clingo_control, semirings, weights_per_semiring, transforms, self.queries)

    def _prepare_grounding(self, program):
        new_program = []
        for r in program:
            if isinstance(r, str):
                new_program.append(r)
            elif r.weights is not None and r.weights[0] == &#39;?&#39;:
                atom = r.head[0]
                self.decisions.append(str(atom))
                new_program.append(f&#34;{{{atom}}}.&#34;)
            elif r.head is not None and r.head[0].predicate == &#34;utility&#34;:
                atom = r.head[0].inputs[0]
                utility = r.head[0].inputs[1]
                phase = True
                if atom.negated:
                    phase = False
                    atom.negated = False
                self.utilities[(str(atom), phase)] = float(utility)
            elif r.head is not None and r.head[0].predicate == &#34;query&#34;:
                atom = r.head[0].inputs[0]
                logger.warning(f&#34;Ignoring query for atom {atom}.&#34;)
            else:
                new_program.append(r)
        return super()._prepare_grounding(new_program)

    def _prog_string(self, program):
        result = &#34;&#34;
        for v in self._guess:
            if self._internal_name(v) in self.decisions:
                result += f&#34;?::{self._external_name(v)}.\n&#34;
            else:
                result += f&#34;{self.weights[self._internal_name(v)]}::{self._external_name(v)}.\n&#34;
        for (name, phase) in self.utilities:
            result += &#34;utility(&#34;
            if not phase:
                result += &#34;\\+&#34;
            result += f&#34;{name}, {self.utilities[(name, phase)]}).\n&#34;
        for r in program:
            result += &#34;;&#34;.join([self._external_name(v) for v in r.head])
            if len(r.body) &gt; 0:
                result += &#34;:-&#34;
                result += &#34;,&#34;.join([(&#34;\\+&#34; if v &lt; 0 else &#34;&#34;) + self._external_name(abs(v)) for v in r.body])
            result += &#34;.\n&#34;
        for query in self.queries:
            result += f&#34;query({query}).\n&#34;
        return result</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="aspmc.programs.dtpasprogram.DTPASProgram"><code class="flex name class">
<span>class <span class="ident">DTPASProgram</span></span>
<span>(</span><span>program_str, program_files)</span>
</code></dt>
<dd>
<div class="desc"><p>A class for Maximum Expected Utility programs. </p>
<p>The syntax for these programs is the same as for ProbLog in MEU mode.
This means that the probabilistic part is specified as usual,
utility atoms <code>a</code>, i.e. atoms whose truth adds utility value <code>u</code> to the model, must be given as <code>utility(a, u).</code> and
the decision atoms <code>d</code>, whose assignment should be maximized over should be given as <code>decision(d).</code>.</p>
<p>Subclasses <code>TwoAlgebraicProgram</code> since it is a second level problem.</p>
<p>Overrides the <code>_prepare_grounding</code> method to deal with utilities and decisions.</p>
<h2 id="args">Args</h2>
<p>program_str (:obj:<code>string</code>): A string containing a part of the program in MEU ProbLog syntax.
May be the empty string.
program_files (:obj:<code>list</code>): A list of string that are paths to files which contain programs in
MEU ProbLog syntax that should be included. May be an empty list.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DTPASProgram(NestedAlgebraicProgram, ProblogProgram):
    &#34;&#34;&#34;A class for Maximum Expected Utility programs. 

    The syntax for these programs is the same as for ProbLog in MEU mode. 
    This means that the probabilistic part is specified as usual,
    utility atoms `a`, i.e. atoms whose truth adds utility value `u` to the model, must be given as `utility(a, u).` and
    the decision atoms `d`, whose assignment should be maximized over should be given as `decision(d).`.

    Subclasses `TwoAlgebraicProgram` since it is a second level problem.

    Overrides the `_prepare_grounding` method to deal with utilities and decisions.

    Args:
        program_str (:obj:`string`): A string containing a part of the program in MEU ProbLog syntax. 
        May be the empty string.
        program_files (:obj:`list`): A list of string that are paths to files which contain programs in 
        MEU ProbLog syntax that should be included. May be an empty list.
    &#34;&#34;&#34;
    def __init__(self, program_str, program_files):
        self.semiring = semiring
        self.weights = {}
        self.utilities = {}
        self.decisions = []
        self.queries = []
        self.annotated_disjunctions = []
        for path in program_files:
            with open(path) as file_:
                program_str += file_.read()
        
        # parse the program
        my_grammar = GRAMMAR + f&#34;&#34;&#34;
        QUESTION_MARK : &#34;?&#34;
        %override weight : /{self.semiring.pattern}/ | variable | QUESTION_MARK
        &#34;&#34;&#34;
        parser = Lark(my_grammar, start=&#39;program&#39;, parser=&#39;lalr&#39;, transformer=ProblogTransformer())
        program = parser.parse(program_str)

        # ground the program
        clingo_control = Control()
        self._ground(clingo_control, program)

        # set the weights
        first_weight_list = {}
        # weights for the maxplus semiring
        first_semiring.names = [ name for name in self.decisions ]
        for i,name in enumerate(self.decisions):
            first_weight_list[(name, True)] = first_semiring.MinMaxPlusFloat((0, 0), (2**i, 2**i))
            first_weight_list[(name, False)] = first_semiring.one()
        # weights for the expected utility semiring
        second_weight_list = {}
        for name in self.weights:
            second_weight_list[(name, True)] = [self.weights[name], 0.0]
            second_weight_list[(name, False)] = [1.0 - self.weights[name], 0.0]
        third_weight_list = {}
        for (name, phase) in self.utilities:
            if (name, phase) in second_weight_list:
                if (name, phase) in first_weight_list:
                    logger.error(f&#34;Variable {name} cannot be both a decision and probabilistic variable.&#34;)
                    exit(-1)
                second_weight_list[(name, phase)][1] = second_weight_list[(name, phase)][0]*self.utilities[(name, phase)]
            elif (name, phase) in first_weight_list:
                first_weight_list[(name, phase)].value[0] = self.utilities[(name, phase)]
                first_weight_list[(name, phase)].value[1] = self.utilities[(name, phase)]
            else:
                third_weight_list[(name, phase)] = self.utilities[(name, phase)]
        second_weight_list = { i : second_semiring.parse(f&#34;({w[0]},{w[1]},{w[1]})&#34;) for (i, w) in second_weight_list.items() }
        third_weight_list = { i : third_semiring.parse(f&#34;({w},{w})&#34;) for (i, w) in third_weight_list.items() }

        semirings = [ first_semiring, second_semiring, third_semiring ]
        weights_per_semiring = [ first_weight_list, second_weight_list, third_weight_list ]
        transforms = [ &#34;lambda w : (w.value[1], w.value[2])&#34;, &#34;lambda w : (1.0, w.value[0], w.value[1])&#34; ]
        NestedAlgebraicProgram.__init__(self, clingo_control, semirings, weights_per_semiring, transforms, self.queries)

    def _prepare_grounding(self, program):
        new_program = []
        for r in program:
            if isinstance(r, str):
                new_program.append(r)
            elif r.weights is not None and r.weights[0] == &#39;?&#39;:
                atom = r.head[0]
                self.decisions.append(str(atom))
                new_program.append(f&#34;{{{atom}}}.&#34;)
            elif r.head is not None and r.head[0].predicate == &#34;utility&#34;:
                atom = r.head[0].inputs[0]
                utility = r.head[0].inputs[1]
                phase = True
                if atom.negated:
                    phase = False
                    atom.negated = False
                self.utilities[(str(atom), phase)] = float(utility)
            elif r.head is not None and r.head[0].predicate == &#34;query&#34;:
                atom = r.head[0].inputs[0]
                logger.warning(f&#34;Ignoring query for atom {atom}.&#34;)
            else:
                new_program.append(r)
        return super()._prepare_grounding(new_program)

    def _prog_string(self, program):
        result = &#34;&#34;
        for v in self._guess:
            if self._internal_name(v) in self.decisions:
                result += f&#34;?::{self._external_name(v)}.\n&#34;
            else:
                result += f&#34;{self.weights[self._internal_name(v)]}::{self._external_name(v)}.\n&#34;
        for (name, phase) in self.utilities:
            result += &#34;utility(&#34;
            if not phase:
                result += &#34;\\+&#34;
            result += f&#34;{name}, {self.utilities[(name, phase)]}).\n&#34;
        for r in program:
            result += &#34;;&#34;.join([self._external_name(v) for v in r.head])
            if len(r.body) &gt; 0:
                result += &#34;:-&#34;
                result += &#34;,&#34;.join([(&#34;\\+&#34; if v &lt; 0 else &#34;&#34;) + self._external_name(abs(v)) for v in r.body])
            result += &#34;.\n&#34;
        for query in self.queries:
            result += f&#34;query({query}).\n&#34;
        return result</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="aspmc.programs.nestedalgebraicprogram.NestedAlgebraicProgram" href="nestedalgebraicprogram.html#aspmc.programs.nestedalgebraicprogram.NestedAlgebraicProgram">NestedAlgebraicProgram</a></li>
<li><a title="aspmc.programs.problogprogram.ProblogProgram" href="problogprogram.html#aspmc.programs.problogprogram.ProblogProgram">ProblogProgram</a></li>
<li><a title="aspmc.programs.program.Program" href="program.html#aspmc.programs.program.Program">Program</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="aspmc.programs.nestedalgebraicprogram.NestedAlgebraicProgram" href="nestedalgebraicprogram.html#aspmc.programs.nestedalgebraicprogram.NestedAlgebraicProgram">NestedAlgebraicProgram</a></b></code>:
<ul class="hlist">
<li><code><a title="aspmc.programs.nestedalgebraicprogram.NestedAlgebraicProgram.choose_clark_completion" href="program.html#aspmc.programs.program.Program.choose_clark_completion">choose_clark_completion</a></code></li>
<li><code><a title="aspmc.programs.nestedalgebraicprogram.NestedAlgebraicProgram.clark_completion" href="program.html#aspmc.programs.program.Program.clark_completion">clark_completion</a></code></li>
<li><code><a title="aspmc.programs.nestedalgebraicprogram.NestedAlgebraicProgram.encoding_stats" href="program.html#aspmc.programs.program.Program.encoding_stats">encoding_stats</a></code></li>
<li><code><a title="aspmc.programs.nestedalgebraicprogram.NestedAlgebraicProgram.get_cnf" href="program.html#aspmc.programs.program.Program.get_cnf">get_cnf</a></code></li>
<li><code><a title="aspmc.programs.nestedalgebraicprogram.NestedAlgebraicProgram.get_queries" href="program.html#aspmc.programs.program.Program.get_queries">get_queries</a></code></li>
<li><code><a title="aspmc.programs.nestedalgebraicprogram.NestedAlgebraicProgram.get_weights" href="program.html#aspmc.programs.program.Program.get_weights">get_weights</a></code></li>
<li><code><a title="aspmc.programs.nestedalgebraicprogram.NestedAlgebraicProgram.td_guided_both_clark_completion" href="program.html#aspmc.programs.program.Program.td_guided_both_clark_completion">td_guided_both_clark_completion</a></code></li>
<li><code><a title="aspmc.programs.nestedalgebraicprogram.NestedAlgebraicProgram.td_guided_clark_completion" href="program.html#aspmc.programs.program.Program.td_guided_clark_completion">td_guided_clark_completion</a></code></li>
<li><code><a title="aspmc.programs.nestedalgebraicprogram.NestedAlgebraicProgram.tpUnfold" href="program.html#aspmc.programs.program.Program.tpUnfold">tpUnfold</a></code></li>
<li><code><a title="aspmc.programs.nestedalgebraicprogram.NestedAlgebraicProgram.treeprocess" href="program.html#aspmc.programs.program.Program.treeprocess">treeprocess</a></code></li>
<li><code><a title="aspmc.programs.nestedalgebraicprogram.NestedAlgebraicProgram.write_dimacs" href="program.html#aspmc.programs.program.Program.write_dimacs">write_dimacs</a></code></li>
<li><code><a title="aspmc.programs.nestedalgebraicprogram.NestedAlgebraicProgram.write_prog" href="program.html#aspmc.programs.program.Program.write_prog">write_prog</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="aspmc.programs" href="index.html">aspmc.programs</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="aspmc.programs.dtpasprogram.DTPASProgram" href="#aspmc.programs.dtpasprogram.DTPASProgram">DTPASProgram</a></code></h4>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>