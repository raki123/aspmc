<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>aspmc.compile.constrained_sdd API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>aspmc.compile.constrained_sdd</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import queue
from aspmc.util import *
import networkx as nx
import numpy as np

class Node(object):    
    &#34;&#34;&#34;A node class corresponding to nodes in a `ConstrainedSDD`.
    
    Args:
        type (:obj:`int`): Which type the node has. One of `Node.AND, Node.OR, Node.NEG, Node.IN`.
        name (:obj:`int`): Unique identifier of the node.
        children (:obj:`iterable`, optional): The children of the node. Defaults to `[]`.
        ancestors (:obj:`iterable`, optional): The ancestors of the node. Defaults to `[]`.

    Attributes:
        type (:obj:`int`): Which type the node has. One of `Node.AND, Node.OR, Node.NEG, Node.IN`.
        name (:obj:`int`): Unique identifier of the node. 
        If `type` is `Node.NEG` or `Node.IN` this is the name of the (negated) input variable.
        children (:obj:`iterable`): The children of the node.
        ancestors (:obj:`iterable`): The ancestors of the node. 
        vtree_node (:obj:`int`): The lowest vtree node that this node respects.

    &#34;&#34;&#34;
    AND = 0
    &#34;&#34;&#34;Node type `AND` with value 0. Means that the children are conjoined.&#34;&#34;&#34;
    OR = 1
    &#34;&#34;&#34;Node type `OR` with value 1. Means that the children are disjoined.&#34;&#34;&#34;
    NEG = 2
    &#34;&#34;&#34;Node type `NEG` with value 2. Means that this is a negative input variable.&#34;&#34;&#34;
    IN = 3
    &#34;&#34;&#34;Node type `IN` with value 3. Means that this is a positive input variable.&#34;&#34;&#34;
    AND = 0
    OR = 1
    NEG = 2
    IN = 3
    def __init__(self, type, name, children = [], ancestors = []):
        self.type = type
        self.name = name
        self.vtree_node = None
        if self.type == Node.IN or self.type == Node.NEG:
            self.vtree_node = abs(name)
        self.children = children
        self.ancestors = ancestors

class ConstrainedSDD(object):    
    &#34;&#34;&#34;A circuit class that can store SDDs. 

    Offers methods to perform algebraic model counting on the circuit in linear time in the size of the (smooth) circuit.
    Also offers the same methods statically to avoid storing the circuit in memory. 
    Then the algebraic model counting is performed while reading the circuit.

    Supports the d-DNNF format of c2d and miniC2D for constructing circuits.
    
    Args:
        path (:obj:`string`): The path to the file that contains the circuit.

    Attributes:
        literals (:obj:`list`): The literals in the circuit. The node for literal `v` is in `literals[2*(v-1)]`, the one for `-v` is in `literals[2*(v-1)+1]`
        nodes (:obj:`list`): All the nodes of the circuit that are not literals.
    &#34;&#34;&#34;
    def __init__(self, path = None, v3 = None):
        if v3 != None:
            self.set_vtree(v3)
        if path != None:
            with open(path) as ddnnf:
                _, nr_nodes, nr_edges, nr_leafs = ddnnf.readline().split()
                self.literals = []
                for var in range(1, int(nr_leafs) + 1):
                    self.literals.append(Node(Node.IN, var))
                    self.literals.append(Node(Node.NEG, -var))
                self.nodes = []
                idx = 0
                for line in ddnnf:
                    line = line.strip().split()
                    if line[0] == &#39;L&#39;:
                        node = self.literals[2*(abs(int(line[1]))-1) + (1 if int(line[1]) &lt; 0 else 0)]
                    elif line[0] == &#39;A&#39;:
                        node = Node(Node.AND, idx, children = [self.nodes[int(x)] for x in line[2:]])
                        for child in node.children:
                            child.ancestors.append(node)
                    elif line[0] == &#39;O&#39;:
                        node = Node(Node.OR, idx, children = [self.nodes[int(x)] for x in line[3:]])
                        for child in node.children:
                            child.ancestors.append(node)
                    self.nodes.append(node)
                    idx += 1

    def set_vtree(self, v3):
        self.vtree = v3
        self.vtree_graph = self.vtree.to_networkx()
        self.vtree.index()
        self.lca = [ [ -1 for _ in range(self.vtree.leaf_count()*2) ] for _ in range(self.vtree.leaf_count()*2) ]
        for p,l in nx.tree_all_pairs_lowest_common_ancestor(self.vtree_graph):
            self.lca[p[1]][p[0]] = l
            self.lca[p[0]][p[1]] = l


    def get_vtree_node(self, node):
        if node.vtree_node is None:
            node.vtree_node = self.lca[(node.children[0].vtree_node, node.children[1].vtree_node)]
        return node.vtree_node
        
    def separator_node(self, P):
        stack = queue.LifoQueue()
        cur = self.vtree
        down = True
        lefts = 0
        seen = set()
        while not (lefts == 0 and seen.issuperset(P)):
            if down:
                if cur.val is None:
                    stack.put(cur)
                    cur = cur.left
                    lefts += 1
                else:
                    seen.add(cur.val)
                    down = False
            else:
                last = cur
                cur = stack.get()
                if last == cur.left:
                    stack.put(cur)
                    cur = cur.right
                    lefts -= 1
                    down = True
        return cur.idx

    def wmc(self, weights, P, first_semiring, second_semiring, transform):        
        &#34;&#34;&#34;Performs (two) algebraic model counting over the X/D-constrained SDD.
        
        Args:
            weights (:obj:`string`): The weights of the literals. The weight for literal `v` is in `weights[2*(v-1)]`, the one for `-v` is in `weights[2*(v-1)+1]`
            P (:obj:`iterable`): The set of variables that are quantified over the first semiring.
            first_semiring (:obj:`module`): The module of the first semiring.
            second_semiring (:obj:`module`): The module of the second semiring.
            transform (:obj:`string`): The transformation function used to transform a value from the second semiring into a value from the first semiring.
                Will be used as

                        f_transform = eval(transform)
                        transform = lambda x : first_semiring.from_value(f_transform(x))
        Returns:
            (:obj:`object`): The algebraic model count.
        &#34;&#34;&#34;
        first_shape = (np.shape(weights[0])[0], ) + np.shape(first_semiring.one())
        second_shape = (np.shape(weights[0])[0], ) + np.shape(second_semiring.one())

        # initialize the transform function
        f_transform = eval(transform)
        transform = lambda x : first_semiring.from_value(f_transform(x))

        separator_node = self.separator_node(P)
        for i in range(len(self.literals)):
            if abs(to_dimacs(i)) in P:
                self.literals[i].weight = weights[i]
            elif self.lca[separator_node][abs(to_dimacs(i))] == separator_node: 
                self.literals[i].weight = weights[i]
            else:
                self.literals[i].weight = np.array([ transform(w) for w in weights[i] ])

        
        index_to_node = { node.idx : node for node in self.vtree.nodes() }
        index_to_node = [ index_to_node[i] for i in range(1, self.vtree.leaf_count()*2) ]
        def factor(i, j):
            if self.lca[i][j] == j: # i should always be above j
                i,j = j,i
            if self.lca[i][separator_node] == separator_node and i not in P:
                res = np.full(second_shape, second_semiring.one())
            else:
                res = np.full(first_shape, first_semiring.one())
            if i == j:
                return res
            upper = index_to_node[i - 1]
            lower = index_to_node[j - 1]
            res = np.full(first_shape, first_semiring.one())
            stack = queue.LifoQueue()
            cur = upper
            down = True
            while cur != upper or down:
                if down:
                    if cur == lower:
                        down = False
                    elif cur.val is None:
                        stack.put(cur)
                        cur = cur.left
                    else:
                        res *= self.literals[to_pos(cur.val)].weight + self.literals[neg(to_pos(cur.val))].weight
                        down = False
                else:
                    last = cur
                    cur = stack.get()
                    if cur.left == last:
                        stack.put(cur)
                        cur = cur.right
                        down = True
            return res

        todo = [ len(node.children) for node in self.nodes ]
        q = queue.Queue()
        for i in range(len(self.nodes)):
            if todo[i] == 0:
                q.put(self.nodes[i])
        while not q.empty():
            node = q.get()
            vtree_node = self.get_vtree_node(node)
            for anc in node.ancestors:
                todo[anc.name] -= 1
                if todo[anc.name] == 0:
                    q.put(anc)
            if self.lca[separator_node][vtree_node] != separator_node:
                if node.type == Node.AND:
                    node.weight = np.empty(first_shape, dtype=first_semiring.dtype)
                    node.weight[:] = first_semiring.one()
                    for child in node.children:
                        child_vtree_node = self.get_vtree_node(child)
                        if self.lca[child_vtree_node][separator_node] == separator_node and child_vtree_node not in P:
                            node.weight *= np.array([ transform(w) for w in child.weight ])
                        else:
                            node.weight *= child.weight
                elif node.type == Node.OR:
                    node.weight = np.empty(first_shape, dtype=first_semiring.dtype)
                    node.weight[:] = first_semiring.zero()
                    for child in node.children:
                        node.weight += child.weight*factor(vtree_node, child.vtree_node)
            else:                
                if node.type == Node.AND:
                    node.weight = np.empty(second_shape, dtype=second_semiring.dtype)
                    node.weight[:] = second_semiring.one()
                    for child in node.children:
                        node.weight *= child.weight
                elif node.type == Node.OR:
                    node.weight = np.empty(second_shape, dtype=second_semiring.dtype)
                    node.weight[:] = second_semiring.zero()
                    for child in node.children:
                        node.weight += child.weight*factor(vtree_node, child.vtree_node)
        node.weight *= factor(node.vtree_node, self.vtree.idx)
        return node.weight

    def parse_wmc(self, path, weights, cnf): # path, weights, P, first_semiring, second_semiring, transform):
        &#34;&#34;&#34;Performs (two) algebraic model counting over an X/D-constrained SDD while parsing it.
        
        Args:
            path (:obj:`string`): The path to the file that contains the SDD.
            weights (:obj:`string`): The weights of the literals. The weight for literal `v` is in `weights[2*(v-1)]`, the one for `-v` is in `weights[2*(v-1)+1]`
            P (:obj:`iterable`): The set of variables that are quantified over the first semiring.
            first_semiring (:obj:`module`): The module of the first semiring.
            second_semiring (:obj:`module`): The module of the second semiring.
            transform (:obj:`string`): The transformation function used to transform a value from the second semiring into a value from the first semiring.
                Will be used as

                        f_transform = eval(transform)
                        transform = lambda x : first_semiring.from_value(f_transform(x))
        Returns:
            (:obj:`object`): The algebraic model count.
        &#34;&#34;&#34;
        shapes = [ (np.shape(weights[0])[0], ) + np.shape(semiring.one()) for semiring in cnf.semirings ]

        first_semiring = cnf.semirings[0]
        second_semiring = cnf.semirings[1]
        
        transform = cnf.transforms[0]

        P = cnf.quantified[0]        
        # initialize the transform function
        f_transform = eval(transform)
        transform = lambda x : first_semiring.from_value(f_transform(x))

        separator_node = self.separator_node(P)
        for i in range(len(weights)):
            if abs(to_dimacs(i)) not in P and self.lca[separator_node][abs(to_dimacs(i))] != separator_node: 
                weights[i] = np.array([ transform(w) for w in weights[i] ])
        
        index_to_node = { node.idx : node for node in self.vtree }
        index_to_node = [ index_to_node[i] for i in range(1, self.vtree.leaf_count()*2) ]

        def factor(i, j):
            if self.lca[i][j] == j: # i should always be above j
                i,j = j,i
            if self.lca[i][separator_node] == separator_node and i not in P:
                res = np.full(shapes[1], second_semiring.one())
            else:
                res = np.full(shapes[0], first_semiring.one())
            if i == j:
                return res
            upper = index_to_node[i - 1]
            lower = index_to_node[j - 1]
            stack = queue.LifoQueue()
            cur = upper
            down = True
            while cur != upper or down:
                if down:
                    if cur == lower:
                        down = False
                    elif cur.val is None:
                        stack.put(cur)
                        cur = cur.left
                    else:
                        res *= weights[to_pos(cur.val)] + weights[neg(to_pos(cur.val))]
                        down = False
                else:
                    last = cur
                    cur = stack.get()
                    if cur.left == last:
                        stack.put(cur)
                        cur = cur.right
                        down = True
            return res

        with open(path) as ddnnf:
            _, nr_nodes, nr_edges, nr_leafs = ddnnf.readline().split()
            mem = []
            vtree_nodes = []
            idx = 0
            for line in ddnnf:
                line = line.strip().split()
                if line[0] == &#39;L&#39;:
                    val = weights[to_pos(int(line[1]))]
                    vtree_node = abs(int(line[1]))
                else:
                    if line[0] == &#39;A&#39;:
                        vtree_node = self.lca[vtree_nodes[int(line[2])]][vtree_nodes[int(line[3])]]
                        if self.lca[separator_node][vtree_node] != separator_node:
                            val = np.empty(shapes[0], dtype=first_semiring.dtype)
                            val[:] = first_semiring.one()
                            for x in line[2:]:
                                x = int(x)
                                child_vtree_node = vtree_nodes[x]
                                if self.lca[child_vtree_node][separator_node] == separator_node and child_vtree_node not in P:
                                    val *= np.array([ transform(w) for w in mem[x] ])
                                else:
                                    val *= mem[x]
                        else:
                            val = np.empty(shapes[1], dtype=second_semiring.dtype)
                            val[:] = second_semiring.one()
                            for x in line[2:]:
                                val *= mem[int(x)]
                    elif line[0] == &#39;O&#39;:
                        vtree_node = self.lca[vtree_nodes[int(line[3])]][vtree_nodes[int(line[4])]]
                        if self.lca[separator_node][vtree_node] != separator_node:
                            val = np.empty(shapes[0], dtype=first_semiring.dtype)
                            val[:] = first_semiring.zero()
                            for x in line[3:]:
                                val += mem[int(x)]*factor(vtree_node, vtree_nodes[int(x)])
                        else:                
                            val = np.empty(shapes[1], dtype=second_semiring.dtype)
                            val[:] = second_semiring.zero()
                            for x in line[3:]:
                                val += mem[int(x)]*factor(vtree_node, vtree_nodes[int(x)])
                mem.append(val)
                vtree_nodes.append(vtree_node)
                idx += 1
            mem[idx - 1] *= factor(vtree_node, self.vtree.idx)
            return mem[idx - 1]</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="aspmc.compile.constrained_sdd.ConstrainedSDD"><code class="flex name class">
<span>class <span class="ident">ConstrainedSDD</span></span>
<span>(</span><span>path=None, v3=None)</span>
</code></dt>
<dd>
<div class="desc"><p>A circuit class that can store SDDs. </p>
<p>Offers methods to perform algebraic model counting on the circuit in linear time in the size of the (smooth) circuit.
Also offers the same methods statically to avoid storing the circuit in memory.
Then the algebraic model counting is performed while reading the circuit.</p>
<p>Supports the d-DNNF format of c2d and miniC2D for constructing circuits.</p>
<h2 id="args">Args</h2>
<p>path (:obj:<code>string</code>): The path to the file that contains the circuit.</p>
<h2 id="attributes">Attributes</h2>
<p>literals (:obj:<code>list</code>): The literals in the circuit. The node for literal <code>v</code> is in <code>literals[2*(v-1)]</code>, the one for <code>-v</code> is in <code>literals[2*(v-1)+1]</code>
nodes (:obj:<code>list</code>): All the nodes of the circuit that are not literals.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ConstrainedSDD(object):    
    &#34;&#34;&#34;A circuit class that can store SDDs. 

    Offers methods to perform algebraic model counting on the circuit in linear time in the size of the (smooth) circuit.
    Also offers the same methods statically to avoid storing the circuit in memory. 
    Then the algebraic model counting is performed while reading the circuit.

    Supports the d-DNNF format of c2d and miniC2D for constructing circuits.
    
    Args:
        path (:obj:`string`): The path to the file that contains the circuit.

    Attributes:
        literals (:obj:`list`): The literals in the circuit. The node for literal `v` is in `literals[2*(v-1)]`, the one for `-v` is in `literals[2*(v-1)+1]`
        nodes (:obj:`list`): All the nodes of the circuit that are not literals.
    &#34;&#34;&#34;
    def __init__(self, path = None, v3 = None):
        if v3 != None:
            self.set_vtree(v3)
        if path != None:
            with open(path) as ddnnf:
                _, nr_nodes, nr_edges, nr_leafs = ddnnf.readline().split()
                self.literals = []
                for var in range(1, int(nr_leafs) + 1):
                    self.literals.append(Node(Node.IN, var))
                    self.literals.append(Node(Node.NEG, -var))
                self.nodes = []
                idx = 0
                for line in ddnnf:
                    line = line.strip().split()
                    if line[0] == &#39;L&#39;:
                        node = self.literals[2*(abs(int(line[1]))-1) + (1 if int(line[1]) &lt; 0 else 0)]
                    elif line[0] == &#39;A&#39;:
                        node = Node(Node.AND, idx, children = [self.nodes[int(x)] for x in line[2:]])
                        for child in node.children:
                            child.ancestors.append(node)
                    elif line[0] == &#39;O&#39;:
                        node = Node(Node.OR, idx, children = [self.nodes[int(x)] for x in line[3:]])
                        for child in node.children:
                            child.ancestors.append(node)
                    self.nodes.append(node)
                    idx += 1

    def set_vtree(self, v3):
        self.vtree = v3
        self.vtree_graph = self.vtree.to_networkx()
        self.vtree.index()
        self.lca = [ [ -1 for _ in range(self.vtree.leaf_count()*2) ] for _ in range(self.vtree.leaf_count()*2) ]
        for p,l in nx.tree_all_pairs_lowest_common_ancestor(self.vtree_graph):
            self.lca[p[1]][p[0]] = l
            self.lca[p[0]][p[1]] = l


    def get_vtree_node(self, node):
        if node.vtree_node is None:
            node.vtree_node = self.lca[(node.children[0].vtree_node, node.children[1].vtree_node)]
        return node.vtree_node
        
    def separator_node(self, P):
        stack = queue.LifoQueue()
        cur = self.vtree
        down = True
        lefts = 0
        seen = set()
        while not (lefts == 0 and seen.issuperset(P)):
            if down:
                if cur.val is None:
                    stack.put(cur)
                    cur = cur.left
                    lefts += 1
                else:
                    seen.add(cur.val)
                    down = False
            else:
                last = cur
                cur = stack.get()
                if last == cur.left:
                    stack.put(cur)
                    cur = cur.right
                    lefts -= 1
                    down = True
        return cur.idx

    def wmc(self, weights, P, first_semiring, second_semiring, transform):        
        &#34;&#34;&#34;Performs (two) algebraic model counting over the X/D-constrained SDD.
        
        Args:
            weights (:obj:`string`): The weights of the literals. The weight for literal `v` is in `weights[2*(v-1)]`, the one for `-v` is in `weights[2*(v-1)+1]`
            P (:obj:`iterable`): The set of variables that are quantified over the first semiring.
            first_semiring (:obj:`module`): The module of the first semiring.
            second_semiring (:obj:`module`): The module of the second semiring.
            transform (:obj:`string`): The transformation function used to transform a value from the second semiring into a value from the first semiring.
                Will be used as

                        f_transform = eval(transform)
                        transform = lambda x : first_semiring.from_value(f_transform(x))
        Returns:
            (:obj:`object`): The algebraic model count.
        &#34;&#34;&#34;
        first_shape = (np.shape(weights[0])[0], ) + np.shape(first_semiring.one())
        second_shape = (np.shape(weights[0])[0], ) + np.shape(second_semiring.one())

        # initialize the transform function
        f_transform = eval(transform)
        transform = lambda x : first_semiring.from_value(f_transform(x))

        separator_node = self.separator_node(P)
        for i in range(len(self.literals)):
            if abs(to_dimacs(i)) in P:
                self.literals[i].weight = weights[i]
            elif self.lca[separator_node][abs(to_dimacs(i))] == separator_node: 
                self.literals[i].weight = weights[i]
            else:
                self.literals[i].weight = np.array([ transform(w) for w in weights[i] ])

        
        index_to_node = { node.idx : node for node in self.vtree.nodes() }
        index_to_node = [ index_to_node[i] for i in range(1, self.vtree.leaf_count()*2) ]
        def factor(i, j):
            if self.lca[i][j] == j: # i should always be above j
                i,j = j,i
            if self.lca[i][separator_node] == separator_node and i not in P:
                res = np.full(second_shape, second_semiring.one())
            else:
                res = np.full(first_shape, first_semiring.one())
            if i == j:
                return res
            upper = index_to_node[i - 1]
            lower = index_to_node[j - 1]
            res = np.full(first_shape, first_semiring.one())
            stack = queue.LifoQueue()
            cur = upper
            down = True
            while cur != upper or down:
                if down:
                    if cur == lower:
                        down = False
                    elif cur.val is None:
                        stack.put(cur)
                        cur = cur.left
                    else:
                        res *= self.literals[to_pos(cur.val)].weight + self.literals[neg(to_pos(cur.val))].weight
                        down = False
                else:
                    last = cur
                    cur = stack.get()
                    if cur.left == last:
                        stack.put(cur)
                        cur = cur.right
                        down = True
            return res

        todo = [ len(node.children) for node in self.nodes ]
        q = queue.Queue()
        for i in range(len(self.nodes)):
            if todo[i] == 0:
                q.put(self.nodes[i])
        while not q.empty():
            node = q.get()
            vtree_node = self.get_vtree_node(node)
            for anc in node.ancestors:
                todo[anc.name] -= 1
                if todo[anc.name] == 0:
                    q.put(anc)
            if self.lca[separator_node][vtree_node] != separator_node:
                if node.type == Node.AND:
                    node.weight = np.empty(first_shape, dtype=first_semiring.dtype)
                    node.weight[:] = first_semiring.one()
                    for child in node.children:
                        child_vtree_node = self.get_vtree_node(child)
                        if self.lca[child_vtree_node][separator_node] == separator_node and child_vtree_node not in P:
                            node.weight *= np.array([ transform(w) for w in child.weight ])
                        else:
                            node.weight *= child.weight
                elif node.type == Node.OR:
                    node.weight = np.empty(first_shape, dtype=first_semiring.dtype)
                    node.weight[:] = first_semiring.zero()
                    for child in node.children:
                        node.weight += child.weight*factor(vtree_node, child.vtree_node)
            else:                
                if node.type == Node.AND:
                    node.weight = np.empty(second_shape, dtype=second_semiring.dtype)
                    node.weight[:] = second_semiring.one()
                    for child in node.children:
                        node.weight *= child.weight
                elif node.type == Node.OR:
                    node.weight = np.empty(second_shape, dtype=second_semiring.dtype)
                    node.weight[:] = second_semiring.zero()
                    for child in node.children:
                        node.weight += child.weight*factor(vtree_node, child.vtree_node)
        node.weight *= factor(node.vtree_node, self.vtree.idx)
        return node.weight

    def parse_wmc(self, path, weights, cnf): # path, weights, P, first_semiring, second_semiring, transform):
        &#34;&#34;&#34;Performs (two) algebraic model counting over an X/D-constrained SDD while parsing it.
        
        Args:
            path (:obj:`string`): The path to the file that contains the SDD.
            weights (:obj:`string`): The weights of the literals. The weight for literal `v` is in `weights[2*(v-1)]`, the one for `-v` is in `weights[2*(v-1)+1]`
            P (:obj:`iterable`): The set of variables that are quantified over the first semiring.
            first_semiring (:obj:`module`): The module of the first semiring.
            second_semiring (:obj:`module`): The module of the second semiring.
            transform (:obj:`string`): The transformation function used to transform a value from the second semiring into a value from the first semiring.
                Will be used as

                        f_transform = eval(transform)
                        transform = lambda x : first_semiring.from_value(f_transform(x))
        Returns:
            (:obj:`object`): The algebraic model count.
        &#34;&#34;&#34;
        shapes = [ (np.shape(weights[0])[0], ) + np.shape(semiring.one()) for semiring in cnf.semirings ]

        first_semiring = cnf.semirings[0]
        second_semiring = cnf.semirings[1]
        
        transform = cnf.transforms[0]

        P = cnf.quantified[0]        
        # initialize the transform function
        f_transform = eval(transform)
        transform = lambda x : first_semiring.from_value(f_transform(x))

        separator_node = self.separator_node(P)
        for i in range(len(weights)):
            if abs(to_dimacs(i)) not in P and self.lca[separator_node][abs(to_dimacs(i))] != separator_node: 
                weights[i] = np.array([ transform(w) for w in weights[i] ])
        
        index_to_node = { node.idx : node for node in self.vtree }
        index_to_node = [ index_to_node[i] for i in range(1, self.vtree.leaf_count()*2) ]

        def factor(i, j):
            if self.lca[i][j] == j: # i should always be above j
                i,j = j,i
            if self.lca[i][separator_node] == separator_node and i not in P:
                res = np.full(shapes[1], second_semiring.one())
            else:
                res = np.full(shapes[0], first_semiring.one())
            if i == j:
                return res
            upper = index_to_node[i - 1]
            lower = index_to_node[j - 1]
            stack = queue.LifoQueue()
            cur = upper
            down = True
            while cur != upper or down:
                if down:
                    if cur == lower:
                        down = False
                    elif cur.val is None:
                        stack.put(cur)
                        cur = cur.left
                    else:
                        res *= weights[to_pos(cur.val)] + weights[neg(to_pos(cur.val))]
                        down = False
                else:
                    last = cur
                    cur = stack.get()
                    if cur.left == last:
                        stack.put(cur)
                        cur = cur.right
                        down = True
            return res

        with open(path) as ddnnf:
            _, nr_nodes, nr_edges, nr_leafs = ddnnf.readline().split()
            mem = []
            vtree_nodes = []
            idx = 0
            for line in ddnnf:
                line = line.strip().split()
                if line[0] == &#39;L&#39;:
                    val = weights[to_pos(int(line[1]))]
                    vtree_node = abs(int(line[1]))
                else:
                    if line[0] == &#39;A&#39;:
                        vtree_node = self.lca[vtree_nodes[int(line[2])]][vtree_nodes[int(line[3])]]
                        if self.lca[separator_node][vtree_node] != separator_node:
                            val = np.empty(shapes[0], dtype=first_semiring.dtype)
                            val[:] = first_semiring.one()
                            for x in line[2:]:
                                x = int(x)
                                child_vtree_node = vtree_nodes[x]
                                if self.lca[child_vtree_node][separator_node] == separator_node and child_vtree_node not in P:
                                    val *= np.array([ transform(w) for w in mem[x] ])
                                else:
                                    val *= mem[x]
                        else:
                            val = np.empty(shapes[1], dtype=second_semiring.dtype)
                            val[:] = second_semiring.one()
                            for x in line[2:]:
                                val *= mem[int(x)]
                    elif line[0] == &#39;O&#39;:
                        vtree_node = self.lca[vtree_nodes[int(line[3])]][vtree_nodes[int(line[4])]]
                        if self.lca[separator_node][vtree_node] != separator_node:
                            val = np.empty(shapes[0], dtype=first_semiring.dtype)
                            val[:] = first_semiring.zero()
                            for x in line[3:]:
                                val += mem[int(x)]*factor(vtree_node, vtree_nodes[int(x)])
                        else:                
                            val = np.empty(shapes[1], dtype=second_semiring.dtype)
                            val[:] = second_semiring.zero()
                            for x in line[3:]:
                                val += mem[int(x)]*factor(vtree_node, vtree_nodes[int(x)])
                mem.append(val)
                vtree_nodes.append(vtree_node)
                idx += 1
            mem[idx - 1] *= factor(vtree_node, self.vtree.idx)
            return mem[idx - 1]</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="aspmc.compile.constrained_sdd.ConstrainedSDD.get_vtree_node"><code class="name flex">
<span>def <span class="ident">get_vtree_node</span></span>(<span>self, node)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_vtree_node(self, node):
    if node.vtree_node is None:
        node.vtree_node = self.lca[(node.children[0].vtree_node, node.children[1].vtree_node)]
    return node.vtree_node</code></pre>
</details>
</dd>
<dt id="aspmc.compile.constrained_sdd.ConstrainedSDD.parse_wmc"><code class="name flex">
<span>def <span class="ident">parse_wmc</span></span>(<span>self, path, weights, cnf)</span>
</code></dt>
<dd>
<div class="desc"><p>Performs (two) algebraic model counting over an X/D-constrained SDD while parsing it.</p>
<h2 id="args">Args</h2>
<p>path (:obj:<code>string</code>): The path to the file that contains the SDD.
weights (:obj:<code>string</code>): The weights of the literals. The weight for literal <code>v</code> is in <code>weights[2*(v-1)]</code>, the one for <code>-v</code> is in <code>weights[2*(v-1)+1]</code>
P (:obj:<code>iterable</code>): The set of variables that are quantified over the first semiring.
first_semiring (:obj:<code>module</code>): The module of the first semiring.
second_semiring (:obj:<code>module</code>): The module of the second semiring.
transform (:obj:<code>string</code>): The transformation function used to transform a value from the second semiring into a value from the first semiring.
Will be used as</p>
<pre><code>        f_transform = eval(transform)
        transform = lambda x : first_semiring.from_value(f_transform(x))
</code></pre>
<h2 id="returns">Returns</h2>
<p>(:obj:<code>object</code>): The algebraic model count.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def parse_wmc(self, path, weights, cnf): # path, weights, P, first_semiring, second_semiring, transform):
    &#34;&#34;&#34;Performs (two) algebraic model counting over an X/D-constrained SDD while parsing it.
    
    Args:
        path (:obj:`string`): The path to the file that contains the SDD.
        weights (:obj:`string`): The weights of the literals. The weight for literal `v` is in `weights[2*(v-1)]`, the one for `-v` is in `weights[2*(v-1)+1]`
        P (:obj:`iterable`): The set of variables that are quantified over the first semiring.
        first_semiring (:obj:`module`): The module of the first semiring.
        second_semiring (:obj:`module`): The module of the second semiring.
        transform (:obj:`string`): The transformation function used to transform a value from the second semiring into a value from the first semiring.
            Will be used as

                    f_transform = eval(transform)
                    transform = lambda x : first_semiring.from_value(f_transform(x))
    Returns:
        (:obj:`object`): The algebraic model count.
    &#34;&#34;&#34;
    shapes = [ (np.shape(weights[0])[0], ) + np.shape(semiring.one()) for semiring in cnf.semirings ]

    first_semiring = cnf.semirings[0]
    second_semiring = cnf.semirings[1]
    
    transform = cnf.transforms[0]

    P = cnf.quantified[0]        
    # initialize the transform function
    f_transform = eval(transform)
    transform = lambda x : first_semiring.from_value(f_transform(x))

    separator_node = self.separator_node(P)
    for i in range(len(weights)):
        if abs(to_dimacs(i)) not in P and self.lca[separator_node][abs(to_dimacs(i))] != separator_node: 
            weights[i] = np.array([ transform(w) for w in weights[i] ])
    
    index_to_node = { node.idx : node for node in self.vtree }
    index_to_node = [ index_to_node[i] for i in range(1, self.vtree.leaf_count()*2) ]

    def factor(i, j):
        if self.lca[i][j] == j: # i should always be above j
            i,j = j,i
        if self.lca[i][separator_node] == separator_node and i not in P:
            res = np.full(shapes[1], second_semiring.one())
        else:
            res = np.full(shapes[0], first_semiring.one())
        if i == j:
            return res
        upper = index_to_node[i - 1]
        lower = index_to_node[j - 1]
        stack = queue.LifoQueue()
        cur = upper
        down = True
        while cur != upper or down:
            if down:
                if cur == lower:
                    down = False
                elif cur.val is None:
                    stack.put(cur)
                    cur = cur.left
                else:
                    res *= weights[to_pos(cur.val)] + weights[neg(to_pos(cur.val))]
                    down = False
            else:
                last = cur
                cur = stack.get()
                if cur.left == last:
                    stack.put(cur)
                    cur = cur.right
                    down = True
        return res

    with open(path) as ddnnf:
        _, nr_nodes, nr_edges, nr_leafs = ddnnf.readline().split()
        mem = []
        vtree_nodes = []
        idx = 0
        for line in ddnnf:
            line = line.strip().split()
            if line[0] == &#39;L&#39;:
                val = weights[to_pos(int(line[1]))]
                vtree_node = abs(int(line[1]))
            else:
                if line[0] == &#39;A&#39;:
                    vtree_node = self.lca[vtree_nodes[int(line[2])]][vtree_nodes[int(line[3])]]
                    if self.lca[separator_node][vtree_node] != separator_node:
                        val = np.empty(shapes[0], dtype=first_semiring.dtype)
                        val[:] = first_semiring.one()
                        for x in line[2:]:
                            x = int(x)
                            child_vtree_node = vtree_nodes[x]
                            if self.lca[child_vtree_node][separator_node] == separator_node and child_vtree_node not in P:
                                val *= np.array([ transform(w) for w in mem[x] ])
                            else:
                                val *= mem[x]
                    else:
                        val = np.empty(shapes[1], dtype=second_semiring.dtype)
                        val[:] = second_semiring.one()
                        for x in line[2:]:
                            val *= mem[int(x)]
                elif line[0] == &#39;O&#39;:
                    vtree_node = self.lca[vtree_nodes[int(line[3])]][vtree_nodes[int(line[4])]]
                    if self.lca[separator_node][vtree_node] != separator_node:
                        val = np.empty(shapes[0], dtype=first_semiring.dtype)
                        val[:] = first_semiring.zero()
                        for x in line[3:]:
                            val += mem[int(x)]*factor(vtree_node, vtree_nodes[int(x)])
                    else:                
                        val = np.empty(shapes[1], dtype=second_semiring.dtype)
                        val[:] = second_semiring.zero()
                        for x in line[3:]:
                            val += mem[int(x)]*factor(vtree_node, vtree_nodes[int(x)])
            mem.append(val)
            vtree_nodes.append(vtree_node)
            idx += 1
        mem[idx - 1] *= factor(vtree_node, self.vtree.idx)
        return mem[idx - 1]</code></pre>
</details>
</dd>
<dt id="aspmc.compile.constrained_sdd.ConstrainedSDD.separator_node"><code class="name flex">
<span>def <span class="ident">separator_node</span></span>(<span>self, P)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def separator_node(self, P):
    stack = queue.LifoQueue()
    cur = self.vtree
    down = True
    lefts = 0
    seen = set()
    while not (lefts == 0 and seen.issuperset(P)):
        if down:
            if cur.val is None:
                stack.put(cur)
                cur = cur.left
                lefts += 1
            else:
                seen.add(cur.val)
                down = False
        else:
            last = cur
            cur = stack.get()
            if last == cur.left:
                stack.put(cur)
                cur = cur.right
                lefts -= 1
                down = True
    return cur.idx</code></pre>
</details>
</dd>
<dt id="aspmc.compile.constrained_sdd.ConstrainedSDD.set_vtree"><code class="name flex">
<span>def <span class="ident">set_vtree</span></span>(<span>self, v3)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_vtree(self, v3):
    self.vtree = v3
    self.vtree_graph = self.vtree.to_networkx()
    self.vtree.index()
    self.lca = [ [ -1 for _ in range(self.vtree.leaf_count()*2) ] for _ in range(self.vtree.leaf_count()*2) ]
    for p,l in nx.tree_all_pairs_lowest_common_ancestor(self.vtree_graph):
        self.lca[p[1]][p[0]] = l
        self.lca[p[0]][p[1]] = l</code></pre>
</details>
</dd>
<dt id="aspmc.compile.constrained_sdd.ConstrainedSDD.wmc"><code class="name flex">
<span>def <span class="ident">wmc</span></span>(<span>self, weights, P, first_semiring, second_semiring, transform)</span>
</code></dt>
<dd>
<div class="desc"><p>Performs (two) algebraic model counting over the X/D-constrained SDD.</p>
<h2 id="args">Args</h2>
<p>weights (:obj:<code>string</code>): The weights of the literals. The weight for literal <code>v</code> is in <code>weights[2*(v-1)]</code>, the one for <code>-v</code> is in <code>weights[2*(v-1)+1]</code>
P (:obj:<code>iterable</code>): The set of variables that are quantified over the first semiring.
first_semiring (:obj:<code>module</code>): The module of the first semiring.
second_semiring (:obj:<code>module</code>): The module of the second semiring.
transform (:obj:<code>string</code>): The transformation function used to transform a value from the second semiring into a value from the first semiring.
Will be used as</p>
<pre><code>        f_transform = eval(transform)
        transform = lambda x : first_semiring.from_value(f_transform(x))
</code></pre>
<h2 id="returns">Returns</h2>
<p>(:obj:<code>object</code>): The algebraic model count.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def wmc(self, weights, P, first_semiring, second_semiring, transform):        
    &#34;&#34;&#34;Performs (two) algebraic model counting over the X/D-constrained SDD.
    
    Args:
        weights (:obj:`string`): The weights of the literals. The weight for literal `v` is in `weights[2*(v-1)]`, the one for `-v` is in `weights[2*(v-1)+1]`
        P (:obj:`iterable`): The set of variables that are quantified over the first semiring.
        first_semiring (:obj:`module`): The module of the first semiring.
        second_semiring (:obj:`module`): The module of the second semiring.
        transform (:obj:`string`): The transformation function used to transform a value from the second semiring into a value from the first semiring.
            Will be used as

                    f_transform = eval(transform)
                    transform = lambda x : first_semiring.from_value(f_transform(x))
    Returns:
        (:obj:`object`): The algebraic model count.
    &#34;&#34;&#34;
    first_shape = (np.shape(weights[0])[0], ) + np.shape(first_semiring.one())
    second_shape = (np.shape(weights[0])[0], ) + np.shape(second_semiring.one())

    # initialize the transform function
    f_transform = eval(transform)
    transform = lambda x : first_semiring.from_value(f_transform(x))

    separator_node = self.separator_node(P)
    for i in range(len(self.literals)):
        if abs(to_dimacs(i)) in P:
            self.literals[i].weight = weights[i]
        elif self.lca[separator_node][abs(to_dimacs(i))] == separator_node: 
            self.literals[i].weight = weights[i]
        else:
            self.literals[i].weight = np.array([ transform(w) for w in weights[i] ])

    
    index_to_node = { node.idx : node for node in self.vtree.nodes() }
    index_to_node = [ index_to_node[i] for i in range(1, self.vtree.leaf_count()*2) ]
    def factor(i, j):
        if self.lca[i][j] == j: # i should always be above j
            i,j = j,i
        if self.lca[i][separator_node] == separator_node and i not in P:
            res = np.full(second_shape, second_semiring.one())
        else:
            res = np.full(first_shape, first_semiring.one())
        if i == j:
            return res
        upper = index_to_node[i - 1]
        lower = index_to_node[j - 1]
        res = np.full(first_shape, first_semiring.one())
        stack = queue.LifoQueue()
        cur = upper
        down = True
        while cur != upper or down:
            if down:
                if cur == lower:
                    down = False
                elif cur.val is None:
                    stack.put(cur)
                    cur = cur.left
                else:
                    res *= self.literals[to_pos(cur.val)].weight + self.literals[neg(to_pos(cur.val))].weight
                    down = False
            else:
                last = cur
                cur = stack.get()
                if cur.left == last:
                    stack.put(cur)
                    cur = cur.right
                    down = True
        return res

    todo = [ len(node.children) for node in self.nodes ]
    q = queue.Queue()
    for i in range(len(self.nodes)):
        if todo[i] == 0:
            q.put(self.nodes[i])
    while not q.empty():
        node = q.get()
        vtree_node = self.get_vtree_node(node)
        for anc in node.ancestors:
            todo[anc.name] -= 1
            if todo[anc.name] == 0:
                q.put(anc)
        if self.lca[separator_node][vtree_node] != separator_node:
            if node.type == Node.AND:
                node.weight = np.empty(first_shape, dtype=first_semiring.dtype)
                node.weight[:] = first_semiring.one()
                for child in node.children:
                    child_vtree_node = self.get_vtree_node(child)
                    if self.lca[child_vtree_node][separator_node] == separator_node and child_vtree_node not in P:
                        node.weight *= np.array([ transform(w) for w in child.weight ])
                    else:
                        node.weight *= child.weight
            elif node.type == Node.OR:
                node.weight = np.empty(first_shape, dtype=first_semiring.dtype)
                node.weight[:] = first_semiring.zero()
                for child in node.children:
                    node.weight += child.weight*factor(vtree_node, child.vtree_node)
        else:                
            if node.type == Node.AND:
                node.weight = np.empty(second_shape, dtype=second_semiring.dtype)
                node.weight[:] = second_semiring.one()
                for child in node.children:
                    node.weight *= child.weight
            elif node.type == Node.OR:
                node.weight = np.empty(second_shape, dtype=second_semiring.dtype)
                node.weight[:] = second_semiring.zero()
                for child in node.children:
                    node.weight += child.weight*factor(vtree_node, child.vtree_node)
    node.weight *= factor(node.vtree_node, self.vtree.idx)
    return node.weight</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="aspmc.compile.constrained_sdd.Node"><code class="flex name class">
<span>class <span class="ident">Node</span></span>
<span>(</span><span>type, name, children=[], ancestors=[])</span>
</code></dt>
<dd>
<div class="desc"><p>A node class corresponding to nodes in a <code><a title="aspmc.compile.constrained_sdd.ConstrainedSDD" href="#aspmc.compile.constrained_sdd.ConstrainedSDD">ConstrainedSDD</a></code>.</p>
<h2 id="args">Args</h2>
<p>type (:obj:<code>int</code>): Which type the node has. One of <code><a title="aspmc.compile.constrained_sdd.Node.AND" href="#aspmc.compile.constrained_sdd.Node.AND">Node.AND</a>, <a title="aspmc.compile.constrained_sdd.Node.OR" href="#aspmc.compile.constrained_sdd.Node.OR">Node.OR</a>, <a title="aspmc.compile.constrained_sdd.Node.NEG" href="#aspmc.compile.constrained_sdd.Node.NEG">Node.NEG</a>, <a title="aspmc.compile.constrained_sdd.Node.IN" href="#aspmc.compile.constrained_sdd.Node.IN">Node.IN</a></code>.
name (:obj:<code>int</code>): Unique identifier of the node.
children (:obj:<code>iterable</code>, optional): The children of the node. Defaults to <code>[]</code>.
ancestors (:obj:<code>iterable</code>, optional): The ancestors of the node. Defaults to <code>[]</code>.</p>
<h2 id="attributes">Attributes</h2>
<p>type (:obj:<code>int</code>): Which type the node has. One of <code><a title="aspmc.compile.constrained_sdd.Node.AND" href="#aspmc.compile.constrained_sdd.Node.AND">Node.AND</a>, <a title="aspmc.compile.constrained_sdd.Node.OR" href="#aspmc.compile.constrained_sdd.Node.OR">Node.OR</a>, <a title="aspmc.compile.constrained_sdd.Node.NEG" href="#aspmc.compile.constrained_sdd.Node.NEG">Node.NEG</a>, <a title="aspmc.compile.constrained_sdd.Node.IN" href="#aspmc.compile.constrained_sdd.Node.IN">Node.IN</a></code>.
name (:obj:<code>int</code>): Unique identifier of the node.
If <code>type</code> is <code><a title="aspmc.compile.constrained_sdd.Node.NEG" href="#aspmc.compile.constrained_sdd.Node.NEG">Node.NEG</a></code> or <code><a title="aspmc.compile.constrained_sdd.Node.IN" href="#aspmc.compile.constrained_sdd.Node.IN">Node.IN</a></code> this is the name of the (negated) input variable.
children (:obj:<code>iterable</code>): The children of the node.
ancestors (:obj:<code>iterable</code>): The ancestors of the node.
vtree_node (:obj:<code>int</code>): The lowest vtree node that this node respects.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Node(object):    
    &#34;&#34;&#34;A node class corresponding to nodes in a `ConstrainedSDD`.
    
    Args:
        type (:obj:`int`): Which type the node has. One of `Node.AND, Node.OR, Node.NEG, Node.IN`.
        name (:obj:`int`): Unique identifier of the node.
        children (:obj:`iterable`, optional): The children of the node. Defaults to `[]`.
        ancestors (:obj:`iterable`, optional): The ancestors of the node. Defaults to `[]`.

    Attributes:
        type (:obj:`int`): Which type the node has. One of `Node.AND, Node.OR, Node.NEG, Node.IN`.
        name (:obj:`int`): Unique identifier of the node. 
        If `type` is `Node.NEG` or `Node.IN` this is the name of the (negated) input variable.
        children (:obj:`iterable`): The children of the node.
        ancestors (:obj:`iterable`): The ancestors of the node. 
        vtree_node (:obj:`int`): The lowest vtree node that this node respects.

    &#34;&#34;&#34;
    AND = 0
    &#34;&#34;&#34;Node type `AND` with value 0. Means that the children are conjoined.&#34;&#34;&#34;
    OR = 1
    &#34;&#34;&#34;Node type `OR` with value 1. Means that the children are disjoined.&#34;&#34;&#34;
    NEG = 2
    &#34;&#34;&#34;Node type `NEG` with value 2. Means that this is a negative input variable.&#34;&#34;&#34;
    IN = 3
    &#34;&#34;&#34;Node type `IN` with value 3. Means that this is a positive input variable.&#34;&#34;&#34;
    AND = 0
    OR = 1
    NEG = 2
    IN = 3
    def __init__(self, type, name, children = [], ancestors = []):
        self.type = type
        self.name = name
        self.vtree_node = None
        if self.type == Node.IN or self.type == Node.NEG:
            self.vtree_node = abs(name)
        self.children = children
        self.ancestors = ancestors</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="aspmc.compile.constrained_sdd.Node.AND"><code class="name">var <span class="ident">AND</span></code></dt>
<dd>
<div class="desc"><p>Node type <code>AND</code> with value 0. Means that the children are conjoined.</p></div>
</dd>
<dt id="aspmc.compile.constrained_sdd.Node.IN"><code class="name">var <span class="ident">IN</span></code></dt>
<dd>
<div class="desc"><p>Node type <code>IN</code> with value 3. Means that this is a positive input variable.</p></div>
</dd>
<dt id="aspmc.compile.constrained_sdd.Node.NEG"><code class="name">var <span class="ident">NEG</span></code></dt>
<dd>
<div class="desc"><p>Node type <code>NEG</code> with value 2. Means that this is a negative input variable.</p></div>
</dd>
<dt id="aspmc.compile.constrained_sdd.Node.OR"><code class="name">var <span class="ident">OR</span></code></dt>
<dd>
<div class="desc"><p>Node type <code>OR</code> with value 1. Means that the children are disjoined.</p></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="aspmc.compile" href="index.html">aspmc.compile</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="aspmc.compile.constrained_sdd.ConstrainedSDD" href="#aspmc.compile.constrained_sdd.ConstrainedSDD">ConstrainedSDD</a></code></h4>
<ul class="">
<li><code><a title="aspmc.compile.constrained_sdd.ConstrainedSDD.get_vtree_node" href="#aspmc.compile.constrained_sdd.ConstrainedSDD.get_vtree_node">get_vtree_node</a></code></li>
<li><code><a title="aspmc.compile.constrained_sdd.ConstrainedSDD.parse_wmc" href="#aspmc.compile.constrained_sdd.ConstrainedSDD.parse_wmc">parse_wmc</a></code></li>
<li><code><a title="aspmc.compile.constrained_sdd.ConstrainedSDD.separator_node" href="#aspmc.compile.constrained_sdd.ConstrainedSDD.separator_node">separator_node</a></code></li>
<li><code><a title="aspmc.compile.constrained_sdd.ConstrainedSDD.set_vtree" href="#aspmc.compile.constrained_sdd.ConstrainedSDD.set_vtree">set_vtree</a></code></li>
<li><code><a title="aspmc.compile.constrained_sdd.ConstrainedSDD.wmc" href="#aspmc.compile.constrained_sdd.ConstrainedSDD.wmc">wmc</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="aspmc.compile.constrained_sdd.Node" href="#aspmc.compile.constrained_sdd.Node">Node</a></code></h4>
<ul class="">
<li><code><a title="aspmc.compile.constrained_sdd.Node.AND" href="#aspmc.compile.constrained_sdd.Node.AND">AND</a></code></li>
<li><code><a title="aspmc.compile.constrained_sdd.Node.IN" href="#aspmc.compile.constrained_sdd.Node.IN">IN</a></code></li>
<li><code><a title="aspmc.compile.constrained_sdd.Node.NEG" href="#aspmc.compile.constrained_sdd.Node.NEG">NEG</a></code></li>
<li><code><a title="aspmc.compile.constrained_sdd.Node.OR" href="#aspmc.compile.constrained_sdd.Node.OR">OR</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>